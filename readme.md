# Recipe-Automation


## Краткий ликбез в код
Каждый объект типа `Recipe`, `Product`, `Ingredient`, etc поддерживает следующие операции:
 * `create ...`. В качестве аргументов указываются поля объекта (подробнее про поля можно посмотреть в `Model.py`). Необязательно указывать все поля, можно специфицировать (например, `create_nutrition(fiber="IAMFIBER)`). Однако, нельзя опускать поля, где `nullable=False`. Если такой объект уже создан – вернет `id` уже существующего.  
 * `retrieve by id...`. Отдаст объект из таблички по `id` в формате, указанном в `Schema.py` 
 * `update by id...`. Обновит поля объекта по `id`. Так же можно указывать не все поля, а только те которые хотим изменить, остальные не изменятся. 
 * `get_..._id_by_parameters`. У нас не существует абсолютно одинаковых строк в таблицах, поэтому набор значений полей взаимно однозначно матчится с их `id`. Если у тебя есть продукт со значениями `a, b, c` по `id = 4`, то `get_product_id_by_parameters(a, b, c)` даст тебе `4`.
 * `delete..._by_id`. Удалит объект из таблички. BUG! Он удалит и запись из ассоциативных таблиц (что хорошо), но пока что он не удаляет зависимые сущности (то есть если ты удаляешь рецепт, то он удалит отношения между этим рецептом и его ингредиентами, но не удалит сами ингредиенты из таблички с ингредиентами, что не очень хорошо).
 
Сигнатуры этих функций можно посмотреть в `domain.py` (чтобы не мешал сам код, сделай `collapse all`)

## На уровень выше
Написан `loader` для рецептов, он принимает на вход рецепт который мы получаем из `html` файла и записывает в базу данных все его объекты и связи между ними.

Полагаю, что для продуктов нужен такой же. Пример как это может работать можно посмотреть в `loaders.py`. Могу без проблем написать, только скажи как ты хранишь продукты и дай соответствующий контейнерный класс (они могут отличаться с классом из базы, это нормально).

* `def load_unchecked_products(ingredient_id: int, id_list: List[int])`. Для хранения непроверенных матчей, создают линки между ингредиентом и потениальными продуктами

* `def load_matched_product(ingredient_id: int, product_id: int)`. Для проверенных матчей


## Важное

* Все функции асинхронные, поэтому перед каждой нужно писать `await`, то есть `id = await retrieve_recipe_by_title("lala")`. Если возникает ошибка или подсказка, где написано что-то про `Coroutine`, то ты точно забыл где-то `await`

* Там есть свои особенности работы функций, особенно то что связано с `update`, могу рассказать про это завтра и ответить на все вопросы, поэтому:

* Советую читать лог, он создается автоматически. Всякие `info` говорят о том что ты попытался создать то что уже есть, это нестрашно. Все остальное тоже не страшно на самом деле, оно завершит работу в любом случае, но лучше проверить что там нет динозавров

